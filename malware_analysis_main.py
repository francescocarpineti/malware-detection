import os
import pandas
import random
from sklearn.model_selection import KFold
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.naive_bayes import MultinomialNB
from sklearn.metrics import accuracy_score, confusion_matrix, precision_score, recall_score


def main():
	
	applications = set(os.listdir('./drebin/feature_vectors'))

	#Data extraction
	apps_fraction = set(random.sample(applications, int(len(applications)/8)))

	malwares = set(pandas.read_csv('./drebin/sha256_family.csv')['sha256'])
	malwares_fraction = set(random.sample(malwares, int(len(malwares)/5)))
	non_malwares = apps_fraction.difference(malwares_fraction)
	
	dataset = list()
	#Features subset chosen
	features = { 'permission', 'api_call', 'real_permission', 'url'}
	
	#Adding malware and non_malware informations to dataset
	for malware in malwares_fraction:
		f = open('./drebin/feature_vectors/'+str(malware))
		infos = ''
		lines = f.readlines()
		for line in lines:
			row = line.strip().split("::")
			if row[0] in features:
				infos += row[1] + ','
		dataset.append([infos, 'malware'])
		f.close()

	for non_malware in non_malwares:
		f = open('./drebin/feature_vectors/'+str(non_malware))
		infos = ''
		lines = f.readlines()
		for line in lines:
			row = line.strip().split('::')
			if row[0] in features:
				infos += row[1] + ','
		dataset.append([infos, 'not_malware'])
		f.close()
	
	#Shuffling the dataset in order to avoid problems in learning
	random.shuffle(dataset)

	#KFold Cross Evaluator instance from sklearn library
	kf = KFold(n_splits = 35)

	test_number = 1
	accuracy_sum = 0
	precision_sum = 0
	recall_sum = 0
	fmeasure_sum = 0

	for training_index, test_index in kf.split(dataset):

		#Preparing data for learning procedure
		training_infos = list()
		test_infos = list()
		training_class = list()
		test_class = list()

		for i in training_index:
			training_infos.append(dataset[i][0])
			training_class.append(dataset[i][1])
		for j in test_index:
			test_infos.append(dataset[j][0])
			test_class.append(dataset[j][1])
		
		#Vectorizer needed to parse MultinomialNB input properly
		vectorizer = CountVectorizer()

		multinomial_clf = MultinomialNB()

		
		training_infos_vec = vectorizer.fit_transform(training_infos)
		multinomial_clf.fit(training_infos_vec, training_class)
		test_infos_vec = vectorizer.transform(test_infos)

		#Using classifier to predict application class
		predicted_value = multinomial_clf.predict(test_infos_vec)

		#Calculating learning method accuracy, precision, recall, f-measure
		accuracy = accuracy_score(test_class, predicted_value)
		accuracy_percent = accuracy*100
		precision = precision_score(test_class, predicted_value, pos_label='malware')
		recall = recall_score(test_class, predicted_value, pos_label='malware')
		fmeasure = (2*precision*recall) / (precision+recall)

		accuracy_sum += accuracy_percent
		precision_sum += precision
		recall_sum += recall
		fmeasure_sum += fmeasure

		print('Confusion matrix for test nÂ° '+str(test_number)+':')
		print('[malware not_malware] //this is valid for rows indexes too')
		print(confusion_matrix(test_class, predicted_value))

		print('Precision: '+str("%.2f" % precision))
		print('Recall: '+str("%.2f" % recall))
		print('Accuracy: '+str("%.2f" % accuracy_percent)+'%')
		print('F-measure: '+str("%.2f" % fmeasure))
		print()
		test_number += 1
		
	accuracy_final = accuracy_sum / 35
	precision_final = precision_sum / 35
	recall_final = recall_sum / 35
	fmeasure_final = fmeasure_sum / 35
	print('Tests ended. Final average values:')
	print('Accuracy: '+str("%.2f" % accuracy_final)+'%')
	print('Precision: '+str("%.2f" % precision_final))
	print('Recall: '+str("%.2f" % recall_final))
	print('F-measure: '+str("%.2f" % fmeasure_final))
		

main()
